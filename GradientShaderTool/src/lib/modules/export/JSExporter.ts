/**
 * JSExporter - Handles JavaScript-only export functionality
 */
import * as THREE from "three";
import { ShaderApp } from "../../ShaderApp";

export class JSExporter {
  private app: ShaderApp;

  /**
   * Create a JSExporter
   * @param app - Reference to main app
   */
  constructor(app: ShaderApp) {
    this.app = app;
  }
  
  /**
   * Generate JavaScript-only code for existing projects
   * @returns Complete JavaScript code without HTML
   */
  async generateJavaScriptOnly(): Promise<string> {
    const params = this.app.params;
    const transparentBg = params.exportTransparentBg;
    
    // Create renderer options based on transparency setting
    const rendererOptions = transparentBg
      ? '{ antialias: true, alpha: true }'
      : '{ antialias: true }';
    
    // Set clear color based on transparency setting
    const clearColorCode = transparentBg
      ? 'renderer.setClearColor(0x000000, 0);' // Transparent
      : `renderer.setClearColor(new THREE.Color("${params.backgroundColor}"));`;
    
    // Default wireframe color if not defined in params
    const wireframeColor = (params as any).wireframeColor || "#ffffff";
    
    // Get shader code
    const shaderCode = await this.app.exportManager.shaderExporter.generateShaderCode();
    
    return `/**
 * Gradient Shader - Generated by Gradient Shader Tool
 * 
 * This code creates a Three.js scene with a gradient shader.
 * To use this code, you need to have Three.js already loaded in your project.
 * 
 * Usage:
 * 1. Call createGradientShader(container) with your container element
 * 2. Optional: Call dispose() when you want to clean up resources
 */

function createGradientShader(container) {
  // Initialize Three.js scene
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(${params.cameraFov}, container.clientWidth / container.clientHeight, 0.1, 1000);

  // Set camera position
  camera.position.set(${params.cameraPosX.toFixed(4)}, ${params.cameraPosY.toFixed(4)}, ${params.cameraPosZ.toFixed(4)});

  // Make camera look at the target point
  camera.lookAt(${params.cameraTargetX.toFixed(4)}, ${params.cameraTargetY.toFixed(4)}, ${params.cameraTargetZ.toFixed(4)});

  // Create renderer
  const renderer = new THREE.WebGLRenderer(${rendererOptions});
  renderer.setSize(container.clientWidth, container.clientHeight);
  ${clearColorCode}
  container.appendChild(renderer.domElement);

  // Create shader material with your custom parameters
  const uniforms = {
    uTime: { value: 0.0 },
    uNoiseScaleX: { value: ${params.normalNoiseScaleX} },
    uNoiseScaleY: { value: ${params.normalNoiseScaleY} },
    uNoiseSpeed: { value: ${params.normalNoiseSpeed} },
    uNoiseStrength: { value: ${params.normalNoiseStrength} },
    uNoiseShiftX: { value: ${params.normalNoiseShiftX} },
    uNoiseShiftY: { value: ${params.normalNoiseShiftY} },
    uNoiseShiftSpeed: { value: ${params.normalNoiseShiftSpeed} },
    uColorNoiseScale: { value: ${params.colorNoiseScale} },
    uColorNoiseSpeed: { value: ${params.colorNoiseSpeed} },
    uGradientMode: { value: ${params.gradientMode} },
    uGradientShiftX: { value: ${params.gradientShiftX} },
    uGradientShiftY: { value: ${params.gradientShiftY} },
    uGradientShiftSpeed: { value: ${params.gradientShiftSpeed} },
    uColors: { 
      value: [
        new THREE.Vector3(${this.getRGBValues(params.color1)}),
        new THREE.Vector3(${this.getRGBValues(params.color2)}),
        new THREE.Vector3(${this.getRGBValues(params.color3)}),
        new THREE.Vector3(${this.getRGBValues(params.color4)})
      ] 
    },
    uLightDir: { 
      value: new THREE.Vector3(${params.lightDirX}, ${params.lightDirY}, ${params.lightDirZ}).normalize() 
    },
    uDiffuseIntensity: { value: ${params.diffuseIntensity} },
    uAmbientIntensity: { value: ${params.ambientIntensity} },
    uRimLightIntensity: { value: ${params.rimLightIntensity} },
    uShowWireframe: { value: ${params.showWireframe} },
    uWireframeColor: { value: new THREE.Color("${wireframeColor}") }
  };

  ${shaderCode.replace(/^/gm, '  ')}

  // Create geometry and mesh
  const geometry = new THREE.PlaneGeometry(${params.planeWidth}, ${params.planeHeight}, ${params.planeSegments}, ${params.planeSegments});
  const plane = new THREE.Mesh(geometry, material);
  plane.rotation.x = ${params.rotationX};
  plane.rotation.y = ${params.rotationY};
  plane.rotation.z = ${params.rotationZ};
  scene.add(plane);

  // Animation loop
  let animationFrameId;
  function animate() {
    animationFrameId = requestAnimationFrame(animate);
    
    // Update time uniform
    uniforms.uTime.value += ${params.animationSpeed};
    
    renderer.render(scene, camera);
  }

  // Simple debounce function to limit how often a function runs
  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  
  // Handle window resize with debouncing to prevent flickering
  const handleResize = debounce(() => {
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.render(scene, camera); // Force a render after resize
    }
  }, 10); // Longer debounce time to prevent flickering
  
  // Use both window resize event and ResizeObserver
  window.addEventListener('resize', handleResize);
  
  // Also use ResizeObserver for container size changes other than window resize
  let resizeObserver;
  if (window.ResizeObserver) {
    resizeObserver = new ResizeObserver(debounce(() => {
      handleResize();
    }, 10));
    resizeObserver.observe(container);
  }
  
  // Initial render
  renderer.render(scene, camera);
  
  // Start animation loop
  animate();
  
  // Return dispose function for cleanup
  return {
    dispose: function() {
      // Stop animation
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Remove event listeners
      window.removeEventListener('resize', handleResize);
      
      // Disconnect resize observer
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      
      // Dispose of Three.js resources
      geometry.dispose();
      material.dispose();
      
      // Remove renderer from DOM
      if (renderer.domElement && renderer.domElement.parentElement) {
        renderer.domElement.parentElement.removeChild(renderer.domElement);
      }
      renderer.dispose();
      
      // Clear scene
      scene.clear();
    }
  };
}

// Example usage:
// const container = document.getElementById('gradient-container');
// const gradientShader = createGradientShader(container);
// 
// // To clean up later:
// // gradientShader.dispose();`;
  }
  
  /**
   * Get RGB values from hex color
   * @param hexColor - Hex color string
   * @returns RGB values as comma-separated string
   */
  private getRGBValues(hexColor: string): string {
    const color = new THREE.Color(hexColor);
    return `${color.r}, ${color.g}, ${color.b}`;
  }
}
